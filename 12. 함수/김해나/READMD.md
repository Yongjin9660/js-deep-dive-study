# 12. 함수


## 12.1 함수란?
> 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것  
> 함수는 값이며, 여러 개 존재할 수 있으므로 식별자인 함수 이름 사용 가능  

<br>  


``` jsx
function add(x, y) {          // 함수 정의
  return x + y;
}

var result = add(2, 5);       // 함수 호출
console.log(result);          // 7
```

- 매개 변수 : 함수 내부로 입력을 전달받는 변수  
- 인수 : 입력  
- 반환값 : 출력  

<br>

## 12.2 함수를 사용하는 이유
> 함수를 통해 중복을 제거하고 코드 재사용에 용이함  
> 유지보수의 편의성을 높이고, 코드의 신뢰성/가독성 향상  

<br>

## 12.3 함수 리터럴

``` jsx
// 변수에 함수 리터럴 할당
var f = function add(x, y) {
  return x + y;
}
```
<br>

<h3>💡 함수 리터럴의 구성요소 </h3>

| 구성 요소 | 설명 |
| --- | --- |
|함수 이름 | 1) 함수 이름은 식별자다. 따라서 식별자 네이밍 규칙을 준수해야 한다. |
|          | 2) 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다. |
|          | 3) 함수 이름은 생략할 수 있다. 이름이 있는 기명 함수, 이름이 없는 함수를 무명/익명 함수라고 한다. |
| 매개변수 목록 | 1) 0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분한다. |
|               | 2) 각 매개변수에는 함수를 호출할 때 지정한 인자가 순서대로 할당된다. 즉, 매개변수 목록은 순서에 의미가 있다. |
|               | 3) 매개변수는 함수 몸체 내에서 변수와 동일하게 취급된다. 따라서 매개변수도 변수와 마찬가지로 식별자 네이밍 규칙을 준수해야 한다. |
| 함수 몸체 | 1) 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록이다. |
|           | 2) 함수 몸체는 함수 호출에 의해 실행된다. |

<br>

<h3> ** 일반 객체와 함수 (객체) 와의 차이점 ** </h3>  

- 일반 객체는 호출할 수 없지만 함수는 호출 가능
- 일반 객체에는 없는 함수 객체만의 고유한 프로퍼티를 가짐.  
<br>

## 12.4 함수 정의
<br>

| 함수 정의 방식 | 예시 |
| --- | --- |
|  함수 선언문 | function add (x, y) {    return x + y;                              } |
| 함수 표현식 | var add = function (x, y)  { return x + y;                                }  |
| Function 생성자 함수 | var add = new Function (’x’, ‘y’, ‘return x + y’); |
| 화살표 함수 (ES6) | var add = (x, y) ⇒ x + y; |
<br>

<h2> 1. 함수 선언문 </h2>

``` jsx
// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 참조
// console.dir 은 console.log 와는 달리 함수 객체의 프로퍼티까지 출력
// 단, Node.js 환경에서는 console.log 와 같은 결과가 출력됨.
console.dir(add);           // fadd(x, y)

// 함수 호출
console.log(add(2, 5));     // 7
```

-> 함수 선언문은 함수 리터럴과 형태가 동일함.   

-> 함수 리터럴은 함수 이름 생략이 가능하지만 <u> 함수 선언문은 함수 이름을 생략할 수 없음. </u>   
<br>

```jsx
// 함수 선언문은 함수 이름 생략 X
function (x, y) {
  return x + y;     // SyntaxError
}     
```

-> 함수 선언문은 표현식이 아닌 문이기 때문에 함수 선언문을 실행하면 완료 값 undefined 출력  

-> 표현식이 아닌 문, 즉 <u> 함수 선언문은 변수에 할당할 수 없음.  </u>  
<br>

```jsx
// 함수 선언문은 표현식이 아닌 문이므로 변수에 할당 X
// 하지만 함수 선언문이 변수에 할당되는 것처럼 보인다.
var add = function add(x, y) {
  return x + y;
}

// 함수 호출
console.log(add(2, 5));     // 7
```

** 함수 선언문이 변수에 할당되는 것처럼 보이는 이유   

&ensp;자바스크립트 엔진이 코드의 문맥에 따라 동일한 <u>함수 리터럴</u>이라도
<br> <em> &ensp;&ensp; 1) 표현식이 아닌 문인 함수 선언문으로 해석하는 경우 </em> 
<br> <em> &ensp;&ensp; 2) 표현식인 문인 함수 리터럴 표현식으로 해석하는 경우 </em> 가 존재하기 때문  
<br>

-  함수 선언문은 함수 이름을 생략할 수 없다는 점을 제외하면 함수 리터럴과 형태가 동일  
- 이름이 있는 <em> 기명 함수 리터럴은 함수 선언문 or 함수 리터럴 표현식으로 해석될 가능성 O </em> 
<br>   

- ### 기명 함수 리터럴을 ```단독으로 사용``` (함수 리터럴을 피연산자로 사용하지 않는 경우) 하면 ```함수 선언문``` 으로 해석  
- ### 기명 함수 리터럴이 ```값으로 평가되어야 하는``` 문맥 (함수 리터럴을 변수에 할당하거나 피연산자로 사용하는 경우) 에는 ```함수 리터럴 표현식```으로 해석
<br>

```jsx
// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석
// 함수 리터럴에서는 함수 이름 생략 O
(function bar() {0
  console.log('bar');
});

bar();      // ReferenceError
```
-> 함수 리터럴에서 '함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자' 라고 했기 때문에 함수 몸체 외부에서는 함수 이름으로 함수를 호출할 수 없음.

-> 즉, 함수를 가리키는 식별자가 없어서 ReferenceError 가 발생한 것.
<br><br>

<img src="https://media.vlpt.us/images/minj9_6/post/90f4a91f-a584-4790-b277-6aade14b6c59/image.png" width="500px" height="480px">  
<br><br>

``` jsx
// 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석
// 함수 선언문에서는 함수 이름 생략 X
function foo() {
  console.log('foo');
}

foo();      // foo
```
-> 함수 선언문에서 함수 객체를 가리키는 식별자 foo 를 선언한 적은 없지만 자바스크립트 엔진이 암묵적으로 식별자를 생성함.

-> 자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당함.
<br><br>

<img src="https://media.vlpt.us/images/minj9_6/post/e97dc97d-651f-4ede-a529-8a1677fa0072/image.png"  width="500px" height="480px">  
<br><br>

 <h3>💡 함수는 함수 이름으로 호출하는 것이 아니라 <u> 함수 객체를 가리키는 식별자로 호출</u>함.  </h3><br>

<h2> 2. 함수 표현식 </h2>

> ```변수에 할당되는 값이 함수 리터럴인 문  ```  
> 자바스크립트의 함수는 객체 타입으로, 값처럼 변수에 할당할 수도 있고 프로퍼티 값이 될 수도 있으며 배열의 요소가 될 수 있음 -> 자바스크립트 함수는 일급 객체 (값의 성질을 갖는 객체)   

<br>

```jsx
// 기명 함수 표현식
var add = function foo(x, y) {
  return x + y;
};

// 함수 객체를 가리키는 식별자로 호출
console.log(add(2, 5));

// 함수 이름으로 호출하면 ReferenceError 발생
// 함수 이름은 함수 몸체 내부에서만 유효한 식별자이기 때문
console.log(foo(2, 5));     // ReferenceError 
```

-> 함수를 호출할 때는 함수 객체를 가리키는 식별자 사용  

-> 리터럴의 함수 이름은 함수 몸체 내부에서만 유효한 식별자이기 때문에 함수 이름이 아닌 식별자로 호출  
<br>  

<h2> 3. 함수 생성 시점과 함수 호이스팅 </h2>

```jsx
// 함수 참조
console.dir(add);   // f add(x, y)
console.dir(sub);   // undefined

// 함수 호출
console.log(add(2, 5));   // 7
console.log(sub(2, 5));   // TypeError

// 함수 선언문
function add(x, y) {
  return x + y;
}

// 함수 표현식
var sub = function (x, y) {
  return x - y;
};
```

-> 함수 선언문으로 정의한 함수는 선언문 이전에 호출 O  

-> 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출 X

-> 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 ```함수의 생성 시점이 다르기 때문```  

<br>

모든 선언문이 그렇듯 함수 선언문도 런타임 이전에 자바스크립트 엔진에 의해 함수 객체가 먼저 생성되고, 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하여 함수 객체를 할당함.   
<br>

``` ** 함수 호이스팅 ** ```  

> 함수 선언이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징   
> <em> 함수 선언문에서 코드가 한 줄씩 순차적으로 실행되기 시작하는 런타임에는 이미 함수 객체가 생성되어 있고, 함수 이름과 동일한 식별자에 할당까지 완료된 상태 </em>  

<br>

``` ** 변수 호이스팅과 함수 호이스팅의 차이점 ** ```

> 변수 호이스팅 : var 키워드로 선언된 변수는 <u> undefined 로 초기화 </u> 

> 함수 호이스팅 : 함수 선언문을 통해 암묵적으로 생성된 식별자는 <u> 함수 객체로 초기화 </u>


** 이미지 출처 : https://velog.io/@minj9_6/JavaScript-%ED%95%A8%EC%88%98%EC%9D%98-%EC%A0%95%EC%9D%98%EC%9D%98-4%EA%B0%80%EC%A7%80-%EB%B0%A9%EB%B2%95-%EC%A4%91-%ED%95%A8%EC%88%98-%EC%84%A0%EC%96%B8%EB%AC%B8%EA%B3%BC-%ED%91%9C%ED%98%84%EC%8B%9D%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C