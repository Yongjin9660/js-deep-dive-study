# 38. 브라우저의 렌더링 과정

- **`파싱`**
  - 파싱 (구문 분석) 은 프로그래밍 언어의 문법에 맞게 작성된 텍스트 문서를 읽어 들여 실행하기 위해 텍스트 문서의 문자열을 토큰으로 분해하고, 토큰에 문법적 의미와 구조를 반영하여 트리 구조의 자료구조인 파스 트리를 생성하는 일련의 과정

<br>

- **`렌더링`**
  - 렌더링은 HTML, CSS, 자바스크립트로 작성된 문서를 파싱하여 브라우저에 시각적으로 출력하는 것

<br>

#### \*\* **브라우저의 렌더링 과정**

![img](https://media.vlpt.us/images/vlrtpfdkxm/post/77e56b30-4d2d-47ab-8270-52d60b7b71e6/%E1%84%85%E1%85%A6%E1%86%AB%E1%84%83%E1%85%A5%E1%84%85%E1%85%B5%E1%86%BC%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A5%E1%86%BC.png)

<br>

1. 브라우저는 HTML, CSS, 자바스크립트, 이미지, 폰트 파일 등 **`렌더링에 필요한 리소스를 요청하고 서버로부터 응답을 받는다.`**
   <br>

2. 브라우저의 렌더링 엔진은 서버로부터 응답된 **`HTML 과 CSS 를 파싱하여 DOM 과 CSSOM 을 생성하고 이들을 결합하여 렌더 트리를 생성한다.`**
   <br>

3. 브라우저의 자바스크립트 엔진은 서버로부터 응답된 **`자바스크립트를 파싱하여 AST 를 생성하고 바이트코드로 변환하여 실행한다.`** 이때 자바스크립트는 DOM API 를 통해 DOM 이나 CSSOM 을 변경할 수 있다. 변경된 DOM 과 CSSOM 은 다시 렌더 트리로 결합된다.
   <br>

4. **`렌더 트리를 기반으로 HTML 요소의 레이아웃 (위치와 크기) 을 계산하고 브라우저 화면에 HTML 요소를 페인팅한다.`**

<br>

## 38.1 요청과 응답

- 렌더링에 필요한 리소스는 모두 서버에 존재하므로 필요한 리소스를 서버에 요청하고 서버가 응답한 리소스를 파싱하여 렌더링하는 것 => `브라우저의 핵심 기능`

<br>

\*\* **`리소스란?`**
→ HTML, CSS, 자바스크립트, 이미지, 폰트 등의 정적 파일 또는 서버가 동적으로 생성한 데이터를 의미

<br>

![img](https://media.vlpt.us/images/vlrtpfdkxm/post/f527e891-d345-4fdc-889f-43537a814f0c/URI%20img.jpeg)

<br>

- **서버에 요청을 전송하기 위해 브라우저는 주소창을 제공**
  - 브라우저의 주소창에 URL 을 입력하고 엔터 키를 누르면 URL 의 호스트 이름이 DNS 를 통해 IP 주소로 변환되고, 이 IP 주소를 갖는 서버에게 요청을 전송함.
  - `요청할 정적 파일의 경로와 파일 이름을 URI 의 호스트 뒤의 path 에 기술하여 서버에 요청`
    <br>

![image](https://user-images.githubusercontent.com/77706631/154834417-a1158b89-d743-40bd-b328-21019abd1f97.png)
<br>

- **요청과 응답은 개발자 도구의 Network 패널에서 확인 가능**
  - html 뿐만 아니라 CSS, 자바스크립트, 이미지, 폰트 파일들도 응답된 것을 알 수 있음.
  - `브라우저의 렌더링 엔진이 HTML 을 파싱하는 도중에 외부 리소스를 로드하는 태그를 만나면 HTML 의 파싱을 일시 중단하고 해당 리소스 파일을 서버로 요청하기 때문`
    <br>

\*\* **`외부 리소스를 로드하는 태그란?`**

- CSS 파일을 로드하는 link 태그
- 이미지 파일을 로드하는 img 태그
- 자바스크립트를 로드하는 script 태그 등

<br>

## 38.2 HTTP 1.1과 HTTP 2.0

> HTTP 는 웹에서 브라우저와 서버가 통신하기 위한 프로토콜 (규약)

<br>

#### \*\* `HTTP/1.1 과 HTTP/2 의 차이점`

<br>

![img](https://miro.medium.com/max/1328/1*rf2AnDQyHfGO_ThYfb-hWA.png)

<br>

- **HTTP/1.1**

  - `커넥션당 하나의 요청과 응답만 처리`
  - 리소스의 동시 전송이 불가능하므로 요청할 리소스의 개수에 비례하여 응답 시간 ↑
    <br>

- **HTTP/2**
  - `커넥션당 여러 개의 요청과 응답이 가능`
  - 여러 리소스의 동시 전송이 가능하므로 페이지 로드 속도 ↑
    <br>

## 38.3 HTML 파싱과 DOM 생성

- 브라우저의 요청에 의해 서버가 응답한 `HTML 문서는 문자열로 이루어진 순수한 텍스트`
- 순수한 텍스트인 HTML 문서를 브라우저에 시각적인 픽셀로 렌더링하려면 `HTML 문서를 브라우저가 이해할 수 있는 자료구조 (객체) 로 변환하여 메모리에 저장해야 함.`

<br>

```html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<link rel="stylesheet" href="style.css" />
	</head>
	<body>
		<ul>
			<li id="apple">Apple</li>
			<li id="banana">Banana</li>
			<li id="orange">Orange</li>
		</ul>
		<script src="app.js"></script>
	</body>
</html>
```

<br>

- 브라우저의 렌더링 엔진은 아래 그림과 같이 `응답받은 HTML 문서를 파싱하여 브라우저가 이해할 수 있는 자료구조인 DOM 생성`

<br>

<img style="height:500px;" src="https://devcecy.com/wp-content/uploads/2021/08/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA-2021-08-08-%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE-12.53.03-1536x1237.png">

<br>

1. 서버에 존재하던 HTML 파일이 브라우저의 요청에 의해 응답된다. 이때 **`서버는 브라우저가 요청한 HTML 파일을 읽어 들여 메모리에 저장한 다음 메모리에 저장된 바이트 (2진수) 를 인터넷을 경유하여 응답한다.`**
   <br>

2. 브라우저는 서버가 응답한 HTML 문서를 바이트 (2진수) 형태로 응답받는다.그리고 **`응답된 바이트 형태의 HTML 문서는 meta 태그의 charset 어트리뷰트에 의해 지정된 인코딩 방식을 기준으로 문자열로 변환된다.`**
   <br>

3. **`문자열로 변환된 HTML 문서를 읽어 들여 문법적 의미를 갖는 코드의 최소 단위인 토큰들로 분해한다.`**
   <br>

4. **`각 토큰들을 객체로 변환하여 노드들을 생성한다.`** 토큰의 내용에 따라 문서 노드, 요소 노드, 어트리뷰트 노드, 텍스트 노드가 생성된다. 노드는 이후 DOM 을 구성하는 기본 요소가 된다.
   <br>

5. HTML 요소의 콘텐츠 영역에는 텍스트뿐만 아니라 다른 HTML 요소도 포함될 수 있어 HTML 문서는 중첩 관계를 갖는다. 이때 HTML 요소 간에는 중첩 관계에 의해 부자 관계가 형성되고, 이러한 **`HTML 요소 간의 부자 관계를 반영하여 모든 노드들을 트리 자료구조로 구성한다. 이 노드들로 구성된 트리 자료구조를 DOM 이라 부른다.`**
   <br>

## 38.4 CSS 파싱과 CSSOM 생성

```html
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<link rel="stylesheet" href="style.css" />
	</head>
</html>
```

- 렌더링 엔진은 `HTML 을 처음부터 한 줄씩 순차적으로 파싱하여 DOM 을 생성해나감.`
  <br>

- `DOM 을 생성해나가다가 CSS 를 로드하는 link 태그나 style 태그를 만나면 DOM 생성을 일시 중단`
  <br>

- link 태그의 href 어트리뷰트에 지정된 CSS 파일을 서버에 요청하여 로드한 CSS 파일이나 style 태그 내의 `CSS 를 HTML 과 동일한 파싱 과정 (바이트 → 문자 → 토큰 → 노드 → CSSOM) 을 거쳐 CSSOM 을 생성`

  - ul-li 태그의 상속 관계가 반영되어 아래 그림과 같은 CSSOM 이 생성됨.
    <br>

- `CSS 파싱을 완료하면 HTML 파싱이 중단된 지점부터 다시 HTML 을 파싱하기 시작하여 DOM 생성 재개`
  <br>

<img style="height:300px;" src="https://devcecy.com/wp-content/uploads/2021/08/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA-2021-08-08-%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE-1.14.10.png">
<br>

## 38.5 렌더 트리 생성

- 렌더링 엔진은 서버로부터 응답된 HTML 과 CSS 를 파싱하여 각각 DOM 과 CSSOM 을 생성
- **`DOM 과 CSSOM 은 렌더링을 위해 렌더 트리로 결합됨.`**
  <br>

#### \*\* **렌더 트리란?**

- `렌더링을 위한 트리 구조의 자료구조`
- `브라우저 화면에 렌더링되는 노드만으로 구성됨.`
  - meta 태그, script 태그 등과 같은 브라우저 화면에 렌더링되지 않는 노드들은 포함 X
  - CSS 에 의해 비표시 (ex. display:none) 되는 노드들도 포함 X
    <br>

<img src="https://devcecy.com/wp-content/uploads/2021/08/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA-2021-08-08-%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE-1.25.35.png">

<br>

- 이후 완성된 렌더 트리는 각 HTML 요소의 레이아웃 (위치와 크기) 을 계산하는 데 사용되며, 브라우저 화면에 픽셀을 렌더링하는 페인팅 처리에 입력됨.

<br>

#### \*\* **`렌더 트리와 레이아웃/페인트`**

<img src="https://devcecy.com/wp-content/uploads/2021/08/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA-2021-08-08-%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE-1.28.12-1536x357.png">

<br>

## 38.6 자바스크립트 파싱과 실행

- **`DOM`** 은 HTML 문서의 구조와 정보뿐만 아니라 HTML 요소와 스타일 등을 변경할 수 있는 프로그래밍 인터페이스로서 **`DOM API`** 를 제공

  - DOM API 를 사용하면 이미 생성된 DOM 을 동적으로 조작 가능
    <br>

- **`자바스크립트 파싱과 실행`** 은 브라우저의 렌더링 엔진이 아닌 **자바스크립트 엔진이 처리**
  - 자바스크립트 엔진은 `자바스크립트 코드를 파싱하여 CPU 가 이해할 수 있는 저수준 언어로 변환하고 실행하는 역할`
    <br>
- 자바스크립트 코드를 해석하여 **`AST (추상적 구문 트리)`** 를 생성하고, AST 를 기반으로 인터프리터가 실행할 수 있는 중간 코드인 바이트코드를 생성하여 실행함.
  <br>

#### \*\* **`DOM 생성 도중에 자바스크립트 파싱이 일어나는 과정`**

1. 렌더링 엔진은 HTML 을 한 줄씩 순차적으로 파싱하며 DOM 을 생성해 나가다가 자바스크립트 파일을 로드하는 script 태그나 자바스크립트 코드를 콘텐츠로 담은 script 태그를 만나면 DOM 생성을 일시 중단
   <br>

2. script 태그의 src 어트리뷰트에 정의된 자바스크립트 파일을 서버에 요청하여 로드한 자바스크립트 파일이나 script 태그 내의 자바스크립트 코드를 파싱하기 위해 자바스크립트 엔진에 제어권을 넘김.
   <br>

3. 이후 자바스크립트 파싱과 실행이 종료되면 렌더링 엔진으로 다시 제어권을 넘겨 HTML 파싱이 중단된 지점부터 다시 HTML 파싱을 시작하여 DOM 생성 재개
   <br>

#### \*\* **`자바스크립트 파싱과 실행 단계`**

![img](https://devcecy.com/wp-content/uploads/2021/08/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA-2021-08-08-%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE-2.05.43.png)
<br>

#### 1. 토크나이징

- 단순한 문자열인 자바스크립트 소스코드를 어휘 분석하여 **`문법적 의미를 갖는 코드의 최소 단위인 토큰들로 분해`**
  - 이 과정을 '렉싱' 이라고 부르기도 하지만 토크나이징과 미묘한 차이 O
    <br>

#### 2. 파싱

- **`토큰들의 집합을 구문 분석하여 AST (추상적 구문 트리) 를 생성`**
  - AST 는 토큰에 문법적 의미와 구조를 반영한 트리 구조의 자료구조
    <br>

#### 3. 바이트코드 생성과 실행

- 파싱의 결과물로서 생성된 **`AST 는 인터프리터가 실행할 수 있는 중간 코드인 바이트코드로 변환되고, 인터프리터에 의해 실행됨.`**
  <br>

## 38.7 리플로우와 리페인트

- 자바스크립트 코드에 DOM 이나 CSSOM 을 변경하는 DOM API 가 사용된 경우 DOM 이나 CSSOM 이 변경됨.
  - 이때 변경된 DOM 과 CSSOM 은 다시 렌더 트리로 결합되고, 변경된 렌더 트리를 기반으로 레이아웃과 페인트 과정을 거쳐 브라우저의 화면에 다시 렌더링함. => **`리플로우`** / **`리페인트`**
    <br>

##### \*\* **`리플로우란?`**

- 레이아웃 계산을 다시 하는 것
- 노드 추가/삭제, 요소의 크기/위치 변경, 윈도우 리사이징 등 레이아웃에 영향을 주는 변경이 발생한 경우에 한하여 실행됨.
  <br>

##### \*\* **`리페인트란?`**

- 재결합된 렌더 트리를 기반으로 다시 페인트하는 것
- 레이아웃에 영향이 없는 변경은 리플로우 없이 리페인트만 실행됨.

<br>

## 38.8 자바스크립 파싱에 의한 HTML 파싱 중단

- 지금까지 살펴본 바로는 렌더링 엔진과 자바스크립트 엔진은 병렬적으로 파싱을 실행하지 않고 직렬적으로 수행
- `브라우저는 동기적으로, 즉 위에서 아래 방향으로 순차적으로 HTML, CSS, 자바스크립트를 파싱하고 실행`
- script 태그의 위치에 따라 HTML 파싱이 블로킹되어 DOM 생성이 지연될 수 있다는 것을 의미
- **`script 태그의 위치는 body 요소의 가장 아래에 위치시키는 것이 좋음.`**
  - DOM 이 완성되지 않은 상태에서 자바스크립트가 DOM 을 조작하면 에러 발생 가능성 ↑
  - 자바스크립트 로딩/파싱/실행으로 인해 HTML 요소들의 렌더링에 지장받는 일이 발생하지 않아 페이지 로딩 시간 ↓
    <br>

## 38.9 script 태그의 async/defer 어트리뷰트

- 자바스크립트 파싱에 의한 DOM 생성이 중단되는 문제를 해결하기 위해 HTML5 부터 script 태그에 `async` 와 `defer` 어트리뷰트가 추가됨.
- `단, async 와 defer 어트리뷰트는 src 어트리뷰트를 통해 외부 자바스크립트 파일을 로드하는 경우에만 사용 가능`
  - src 어트리뷰트가 없는 인라인 자바스크립트에는 사용 X
    <br>

```html
<script async src="extern.js"></script>
<script defer src="extern.js"></script>
```

- async 와 defer 어트리뷰트를 사용하면 **`HTML 파싱과 외부 자바스크립트 파일의 로드가 비동기적으로 동시에 진행`** 되지만, **`자바스크립트의 실행 시점에 차이`** 가 있음.
  <br>

#### \*\* **`async 어트리뷰트`**

![img](https://devcecy.com/wp-content/uploads/2021/08/KakaoTalk_Photo_2021-08-08-15-19-54.png)
<br>

- async 어트리뷰트를 사용하면 HTML 파싱과 외부 자바스크립트 파일의 로드가 비동기적으로 동시에 진행됨.
- **`단, 자바스크립트의 파싱과 실행은 자바스크립트 파일의 로드가 완료된 직후 진행되며, 이때 HTML 파싱이 중단됨.`**
- `async 어트리뷰트는 순서 보장이 필요없는 script 태그에 유용`
  - script 태그의 순서와는 상관없이 로드가 완료된 자바스크립트부터 먼저 실행되므로 순서가 보장되지 않기 때문
    <br>

#### \*\* **`defer 어트리뷰트`**

![img](https://devcecy.com/wp-content/uploads/2021/08/KakaoTalk_Photo_2021-08-08-15-20-00.png)
<br>

- defer 어트리뷰트를 사용하면 HTML 파싱과 외부 자바스크립트 파일의 로드가 비동기적으로 동시에 진행됨.
- **`단, 자바스크립트의 파싱과 실행은 HTML 파싱이 완료된 직후, 즉 DOM 생성이 완료된 직후 진행됨.`**
- `defer 어트리뷰트는 DOM 생성이 완료된 이후 실행되어야 할 script 태그에 유용`

<br><br>

\*\* 이미지 출처 : https://velog.io/@vlrtpfdkxm/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B3%BC%EC%A0%95
https://medium.com/@shlee1353/http1-1-vs-http2-0-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EA%B0%84%EB%8B%A8%ED%9E%88-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0-5727b7499b78
https://devcecy.com/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%A0%8C%EB%8D%94%EB%A7%81-%EB%90%A0%EA%B9%8C/
